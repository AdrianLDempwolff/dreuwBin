#!/bin/bash

if [ `hostname` != "ccserv1" ]; then
	echo "Sorry wrong host, please use ccserv1 to run this"
	exit 1
fi

if [ "$1" = "-h" ]; then
	cat << EOF
Toolkit to investigate and modify queue jobs efficiently.
For a list of implemented commands start the Skript and type "help".

Skript makes use of the variable \$USER to execute fiters on the queue, 
so changing this variable in the shell makes it work under a different
username. Logins still work under the name of current user, however.
EOF
	exit 0
fi

#Is there even a job in the queue
if qstat -u $USER | grep $USER > /dev/null; then
	#all fine
	:
else
	echo "!!!   You currently have no job in the queue; Terminating   !!!"
	exit 0
fi

#required for @( ) and ?( ) patterns in case ... and other pathname expansions
shopt -qs extglob

#TODO check for ssh agent and add key if not present
#TODO module to parse user-defined aliases from config file

#########################################################################
#-- command cache --#
#####################
list_commands() {
	#list all commands
	list_commands_none
	echo -n " "
	list_commands_id
	echo -n " "
	list_commands_list
	echo -n " "
	list_commands_node
}

list_commands_none() {
	#get list of commands that require no argument
	fill_list_commands_cache
	echo -n "$COMMANDS_NONE"
}

list_commands_id() {
	#get list of commands that require a single job id
	fill_list_commands_cache
	echo -n "$COMMANDS_ID"
}

list_commands_list() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_LIST"
}

list_commands_node() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_NODE"
}

max_command_length(){
	#get maximum number of characters a command has
	fill_list_commands_cache
	echo -n "$MAX_COMMAND_LENGTH"
}

fill_list_commands_cache() {
	#fill cache for the lists of available commands
	[ "$COMMANDS_NONE" ] && return
	COMMANDS_NONE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_none ().*/\1/p' | tr '\n' ' ')
	COMMANDS_ID=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_id ().*/\1/p' | tr '\n' ' ')
	COMMANDS_LIST=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_list ().*/\1/p' | tr '\n' ' ')
	COMMANDS_NODE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_node ().*/\1/p' | tr '\n' ' ')

	MAX_COMMAND_LENGTH=`list_commands | tr ' ' '\n' | wc --max-line-length`
}

empty_list_commands_cache() {
	COMMANDS_NONE=
	COMMANDS_ID=
	COMMANDS_LIST=
	COMMANDS_NODE=
	MAX_COMMAND_LENGTH=
}

#########################################################################
#-- utils --#
#############

help_string() {
	#marker function that does absolutely nothing
	:
}

print_help_for_command() {
	#$1: command name
	#$2: suffix

	local FCTNAME="c_${1}_${2}"
	local DECLARE
	DECLARE=`declare -f -p $FCTNAME` || return 1
	echo "$DECLARE" | sed -ne '/help_string/s/^.*help_string[[:space:]]*"\(.*\)";[[:space:]]*$/\1/p'
	return 0
}

print_help_for_category() {
	case "$1" in 
		list)
			EXTRA="<list>"
			;;
		id)
			EXTRA="<id>  "
			;;
		none)
			EXTRA="      "
			;;
		node)
			EXTRA="<id>  "
			;;
		*)
			echo "Cannot print help for unknown category $1"
			return 1
	esac

	for cmd in `list_commands_$category`; do
		local COLWIDTH=$(( $(max_command_length) + 6 - ${#cmd} ))
		printf "   \033[0;33m%s\033[0;00m %-${COLWIDTH}s  %s\n" "$cmd" "$EXTRA" "$(print_help_for_command $cmd $category)"
	done
}

#########################################################################
#-- shell --#
#############

shell_loop() {
	LASTJOBID=0
	local RET=0

	echo "Welcome to the interactive PBS queue diagnosis tool."
	echo
	c_summary_none
	echo
	echo "Enter 'help' for a list of implemented commands or 'quit' to quit the shell"

	while true; do
		if [ $RET != 0 ]; then
			echo -e "rc: \033[0;32m$RET\033[0;00m"
		fi

		read -e -p "($(printf "%6s" "$LASTJOBID")) >" LINE
		
		if [ "$LINE" ]; then
			history -s "$LINE"
			run_command $LINE
			RET=$?
		fi
	done
}

substitute_alias() {
	#$1: command to expand
	#$2: nesting count
	#echos the expanded command on stdout, errors on stderr
	
	local NEST=${2:-0}
	local CMD=$1
	if ((NEST > 10)); then
		echo "substitute_alias reached nest count of 10" >&2
		echo "Executing command as is: $CMD" >&2
		echo "$CMD"
	fi

	#TODO: modularise

	case "$CMD" in
		q)	substitute_alias "quit" "$((NEST+1))"
			return
			;;
		*)	echo "$CMD"
			return 
			;;
	esac
}

run_command() {
	# interpret and run a command
	# returns the return code of the function executed
	# alters the global variable LASTJOBID
	# $1: command
	# $2 to $n: arguments

	local CMD="$1"
	local ID=""
	local NODE=""
	local LIST=""
	shift

	[ -z "$CMD" ] && return 0
	
	#fill command if neccessary:
	[ -z "$COMMANDS_NONE" ] && fill_list_commands_cache

	#substitute aliases:
	CMD=$(substitute_alias "$CMD")

	#interpret the command:
	case "$CMD" in
		#the @( ) and ?( ) patterns require extglob !!
		@(${COMMANDS_NONE// /|})?(+([[:space:]])*))
			c_${CMD}_none
			return $?
			;;
		@(${COMMANDS_ID// /|})?(+([[:space:]])*))
			#TODO: determine id from remaining args
			c_${CMD}_id "$ID"
			return $?
			;;
		@(${COMMANDS_NODE// /|})?(+([[:space:]])*))
			#TODO: determine node from remaining args
			c_${CMD}_node "$NODE"
			return $?
			;;
		@(${COMMANDS_LIST// /|})?(+([[:space:]])*))
			#TODO: determine id list from remaining args
			c_${CMD}_list "$LIST"
			return $?
			;;
		*)
			 echo "Unrecognised command: $CMD"
			 echo "Type help for a list of commands"
			 return 1
			 ;;
	esac
}


#########################################################################
#-- commands --#
################
#Note: - functions for commands start with a "c_", followed by the
#        commands name and a suffix for the kind of arguments the 
#        command requires:
#            - "_none" for no argument 
#            - "_id"   for a single job id
#            - "_list" for a list of job ids or a single job id.
#            - "_node" if the job requires a node as the argument
#      - they should contain a line with a help string starting with
#        "help_string" that documents the commands action shortly
#      - if the command requires a single job id to work the functions
#        name has to 

c_quit_none() {
	help_string "Quit shell."
	exit 0
}

c_help_none() {
	help_string "print this help"


	echo "The following commands are implemented:"
	for category in none id node list; do
		print_help_for_category $category
	done

	cat <<- EOF

	<id> is a job id (or a pattern for it)
	<list> is a list of job ids
	EOF
}

c_summary_none() {
	help_string "print a short summary"
	#TODO ideas: fairShare, No of active nodes/processors, how many occupied by me
	#Jobs that are going to run out of walltime soon
	echo $FUNCNAME called
}

c_load_list() {
	help_string "check load and memory usage"
	#check the load and memory usage for this list of jobs
	# (to see if one might be swapping)
	echo $FUNCNAME called
}

c_login_node() {
	help_string "login to the job's node and cd to TMPDIR"
	#llscratchNode
	echo $FUNCNAME called
}

c_top_node() {
	help_string "login to the job's node and call top"
	#ltopNode
	echo $FUNCNAME called
}

c_stats_id() {
	help_string "display some job statistics"
	#echo stats called
	echo $FUNCNAME called
}

c_wtincrease_id() {
	help_string "increase walltime by sending sysadmin an email"
	echo $FUNCNAME called
}

c_delete_list() {
	help_string "delete the jobs"
	#deleteJob
	echo $FUNCNAME called
}



#------------------------------------------------------------------------

function displayHelp() {
	cat << EOF
The following commands are implemented at the moment:
help              displays this help
refresh           refresh qinvestigate display
login <ID>        login to node
top               login to node and execute "top"
delete <ID>       delete job
quit              quit script
experimental      access experimental features.
                  Read code for doc ;)

shorter aliases:
del     same as   delete
h                 help
r                 refresh
q                 quit
l                 login

NOTE: Major refactoring of this code is going on at the moment
      the available methods are likely going to change very soon.
EOF
}

#------------------------------------------------------------------------

function callExperimental() {
	shell_loop
}

function loginNode() {
	ssh $NODE
}

function llscratchNode() {
	ssh -t $NODE "cd /lscratch/$ID; bash -il"
}

function ltopNode() {
	ssh -t $NODE "top"
}

function deleteJob() {
	read -p "Sure you want to delete job $ID?  " RES
	if [ "$RES" == "y" ]; then
		qdel $ID
	fi
}


#------------------------------------------------------------------------

PROMPT="Type in command followed by job ID  (h for help; q quits)  > "
SUPRESS_QSTAT_ON_NEXT_RUN=0
while true; do
	if [ "$SUPRESS_QSTAT_ON_NEXT_RUN" != "1" ]; then
		echo current jobs owned by you:
		qstat -nu $USER | awk '$1 != "--"'
		echo
	else
		SUPRESS_QSTAT_ON_NEXT_RUN=0
	fi

	#read input from user
	ID=""
	COMM=""
	LINE=""
	read -e -p "$PROMPT" LINE
	history -s $LINE
	PROMPT="comm ID  > " #shorten future promts

	if [ "$LINE" == "" ]; then
		#if [ "$QINVESTIGATE_DEFAULT_COMMAND" ]; then
		#	LINE=$QINVESTIGATE_DEFAULT_COMMAND
		#else
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			continue
		#fi
	fi

	COMM=`echo $LINE | awk '{print $1}'`
	ID=`echo $LINE | awk '{print $2}'`

	#do functions without an argument here:
	case $COMM in 
		r)
			continue
			;;
		refresh)
			continue
			;;
		experimental)
			callExperimental $LINE
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
			;;
		q)
			exit 0
			;;
		quit)
			exit 0
			;;
		exit)
			exit 0
			;;
		h)
			echo
			displayHelp
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
			;;
		help)
			echo
			displayHelp
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
			;;
	esac
	echo

	#For all of the rest we need two arguments; if no second argument present try to default to single node if present.
	if [ "$ID" == "" ]; then
		QSTATUSER=`qstat -u $USER | grep $USER`
		if [[ "$QSTATUSER" != "" && `echo $QSTATUSER | awk '{if (NR > 1) {exit}}; END {print NR}'` == 1 ]]; then
			ID=`echo "$QSTATUSER" | awk '{print $1}'`
		else
			echo "!!!  Second argument missing  !!!"
			echo "!!!  Type \"help\" for a list of commands  !!!"
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
		fi
	fi

	# check for valid node argument:
	NODE=`qnodes | grep -B5 "$ID"`
	if [ $? != "0" ]; then
		echo "!!!  Sorry, could not find this host  !!!"
		SUPRESS_QSTAT_ON_NEXT_RUN=1
		echo
		continue
	fi
	if [ `echo "$NODE" | awk '{if (NR > 7) {exit}}; END {print NR}'` -gt "7" ];then
		echo "!!!  Sorry, more than one host did match your criteria  !!!"
		SUPRESS_QSTAT_ON_NEXT_RUN=1
		echo
		continue
	fi
	NODE=`echo "$NODE" | head -n1`

	#normalise ID input
	GREPID=`qstat | grep $ID`
	if [ `echo $GREPID | awk '{if (NR > 1) {exit}}; END {print NR}'` -gt 1 ]; then
		echo "  WARNING: failed to normalised ID input $ID"
		echo "           possible that some features like \"del\" don't work properly"
		read -p "           Continue with execution?  " RES
		if [ "$RES" != "y" ]; then
			echo
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			continue
		fi
	else
		ID=`echo "$GREPID" | awk '{print $1}'`
	fi

	#do functions with argument here
	case $COMM in
		ssh)
			llscratchNode
			;;
		login)
			llscratchNode
			;;
		l)
			llscratchNode
			;;
		llscratch)
			llscratchNode
			;;
		lls)
			llscratchNode
			;;
		top)
			ltopNode
			;;

	#-------------------------------------
		*)
			echo "!!!  Unrecognised command: $COMM  !!!"
			echo "!!!  Type \"help\" for a list of commands  !!!"
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
	esac
done

