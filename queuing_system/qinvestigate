#!/bin/bash

# load library:
. $(dirname $0)/../shared.config.lib.sh

##########################################################################
#Settings
DEVELOPER="info@michael-herbst.com" #main developer of this script
WARNINGWAIT=2 #number of seconds to wait if a warning is issued

#set this to allow @( ) and ?( ) patterns in case ... and other pathname expansions
shopt -qs extglob

#switch to vi or emacs line editing mode
#(needed to allow the binding of \t to "tabcomplete" and hence tab completion)
if set -o | awk '$1 == "emacs" { if ($2 =="off") exit 0; exit 1}'; then
	#no emacs editing mode, hence
	set -o vi
else
	set +o vi
fi

#########################################################################
#-- checks and setup --#
########################

cleanup_before_exit() {
	# function to be called in a trap before 
	# exiting the script

	#remove ssh key in case we added it
	[ "$ADDED_SSH_KEY" ] && ssh-add -d
}

preliminary_checks() {
	#function to be called to set up the environment

	# check host
	if [[ "$HOSTNAME" != "$MASTERHOSTNAME" ]]; then
		echo "Sorry wrong host, please use host $MASTERHOSTNAME to run this."
		exit 1
	fi
	
	# check if job in queue
	if ! qstat -u $USER | grep -q $USER; then
		echo "You currently have no job in the queue"
		exit 0
	fi
}

user_has_ssh_key() {
	#determine if the user has an ssh key

	# here we assume the keys are at the default location
	# ie.
	local KEYLOC="$HOME/.ssh/"
	for key in $KEYLOC/id_{rsa,dsa,ecdsa,ed25519}; do
		[ -r "$key" ] && return 0
	done
	return 1
}

setup_ssh_keys() {
	# function that checks for an ssh-agent
	# and adds the users ssh key

	# check if user has an ssh agent
	if ! ps x -U $USER | grep -q "[s]sh-agent"; then
		cat <<- EOF
		WARNING: No running ssh-agent found
		Currently there is no ssh-agent running for your user on this host.
		This implies that you will have to type your password each time this
		script needs to login to one of the nodes.
		For some commands this can be quite tedious, so the use of an 
		ssh-agent is highly recommended.

		EOF
		sleep $WARNINGWAIT
		return 1
	fi

	# check for keys in ssh-add that is added
	ssh-add -l &> /dev/null && return 0

	# see if user has key to add
	if ! user_has_ssh_key; then
		cat <<- EOF
		WARNING: No ssh public key found
		Currently there is no ssh public key found in your HOME/.ssh folder
		Please generate a key using "ssh-keygen" or (if your key is not 
		at the default location) add it manually to the agent.

		If you have no clue what this means, most probably the first thing
		is the case and I suggest you read the manpage of ssh-keygen ;)

		EOF
		sleep $WARNINGWAIT
		return 1
	fi

	# add user key
	echo Please enter your password to add the ssh key to your agent:
	if ssh-add; then
		trap cleanup_before_exit EXIT
		return 0
	else
		echo WARNING: could not add ssh key
		sleep $WARNINGWAIT
		echo
		return 1
	fi
}

script_usage() {
	# help to print if script is called with -h or --help

	cat <<- EOF
	$(basename $0) [<Options>] [ [ -- ] <qinvestigate command> [ <args> ] ]

	Toolkit to investigate and modify PBS jobs efficiently.
	For a list of implemented commands start the script and type "help" or
	run "$(basename $0) --no-add-sshkey help".

	All arguments after the -- or that are left after the options are parsed
	are interpreted as internal qinvestigate commands and their arguments.

	Available <Options>:
	   --add-sshkey        enable or disable the check for a running ssh-agent
	   --no-add-sshkey     available keys and the automatic querying for a
	                       password to add the key to your agent.
	
	Features of the shell:
	The shell has basic tab completion and tries to match jobs according
	to both JOB ID and JOB name whereever a command requires an <ID> or 
	a <list>.

	The script makes use of the environment variable \$USER to filter out
	the relevant lists for the current user.

	Bugs / Suggestions / Feature Requests:
	      $DEVELOPER
EOF


}

#########################################################################
#-- config management --#
#########################

default_config() {
	# spits out the default configuration

	cat <<- EOF
	# The systax of all options is 
	# <OPTIONNAME> = "<OPTIONVALUE>"
	# Both spaces around the = as well as the " around the
	# <OPTIONVALUE> are optional. 
	# 
	# <OPTIONVALUE> may not continue any of the three characters
	#  " = '

	main {
		# The hostname on which the PBS system runs:
		MASTERHOSTNAME="$MASTERHOSTNAME"

		# Should the script check for a running ssh agent
		# and if the users ssh key is added
		# default is yes
		ADDSSHKEY="$ADDSSHKEY"

		# Absolute number of hours of remaining walltime below which
	       	# job is considered to be running out of walltime very soon.
		WALLTIME_WARNING_ABS=$WALLTIME_WARNING_ABS

		# Relative percentage of remaining walltime below which
		# job is considered to be running out of walltime very soon.
		WALLTIME_WARNING_REL=$WALLTIME_WARNING_REL

	}

	aliases {
		# Type in this block the aliases for the qinvestigate shell
		# The syntax is (similar to bash): 
		#   alias <SHORT FORM>="<LONG FORM>"
		# for example consider
		#   alias l="login"
		# which binds l as an alias for login
		# The <LONG FORM> may not contain any of the three characters
		# = " '
		#
		# examples:
		#alias q="quit"
		#alias l="login"
	}
	EOF
}

parse_config() {
	#Parse mainblock	
	ConfigParseBlock "main" $ALLGLOBALSETTINGS
	case "$?" in
		2)
			echo "main block missing in config file `ConfigPath`" >&2
			echo "Please add at least an empty block \"main {}\"" >&2
			exit 1
			;;
		8)
			echo "The main block of `ConfigPath` contained invalid config options." >&2
			exit 1
			;;
		0)
			#All fine
			:
			;;
		*)	#No Config yet present
			#Dump default:
			default_config | ConfigPut
			echo "NOTICE: Default config dumped in file `ConfigPath`"
			sleep $WARNINGWAIT
			parse_config
		       	return $?
			;;
	esac

	#read and parse alias block
	local ALIASESBLOCK
	if ALIASESBLOCK=`ConfigGetBlock "aliases"`; then
		# parse the alias block into a sequence of commands
		# ALIASES["q"]="quit"
		# ALIASES["l"]="login"
		# ...
		# that will then be evaluated by the shell
		# ignore all entries that are invalid or may cause problems
		# when the shell evals the result
		# (ie those which contain = or ' or " in the string on the RHS of =)
		local ALIASCODE
		if ! ALIASCODE=$(
			echo -n "$ALIASESBLOCK" | awk "
				BEGIN {
					res=0 #return value
				}

				/^alias[[:space:]]+[[:graph:]]+=\\\"[^=\\\"']+\\\"$/ {
					split(\$2,a,\"=\")
					sub(/^\"/,\"\",a[2])
					sub(/\"$/,\"\",a[2])
					print \"ALIASES[\\\"\" a[1] \"\\\"]='\" a[2] \"'\"
					next
				}

				{
					print \"Invalid alias definition: \" \$0  > \"/dev/stderr\"
					res=1
					next
				}

				END {
					exit res
				}
			"
		); then
			echo "WARNING: Some entries of the alias block in `ConfigPath` were ignored." >&2
			sleep $WARNINGWAIT
		fi
		eval "$ALIASCODE"
	fi
}

#########################################################################
#-- command cache --#
#####################

list_commands_aliases() {
	#list all commands and aliases
	list_commands
	echo -n " "
	echo -n "${!ALIASES[@]}"
}

list_commands() {
	#list all commands
	list_commands_none
	echo -n " "
	list_commands_id
	echo -n " "
	list_commands_list
	echo -n " "
	list_commands_node
}

list_commands_none() {
	#get list of commands that require no argument
	fill_list_commands_cache
	echo -n "$COMMANDS_NONE"
}

list_commands_id() {
	#get list of commands that require a single job id
	fill_list_commands_cache
	echo -n "$COMMANDS_ID"
}

list_commands_list() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_LIST"
}

list_commands_node() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_NODE"
}

max_command_length(){
	#get maximum number of characters a command has
	fill_list_commands_cache
	echo -n "$MAX_COMMAND_LENGTH"
}

fill_list_commands_cache() {
	#fill cache for the lists of available commands
	[ "$COMMANDS_NONE" ] && return
	COMMANDS_NONE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_none ().*/\1/p' | tr '\n' ' ')
	COMMANDS_ID=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_id ().*/\1/p' | tr '\n' ' ')
	COMMANDS_LIST=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_list ().*/\1/p' | tr '\n' ' ')
	COMMANDS_NODE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_node ().*/\1/p' | tr '\n' ' ')

	MAX_COMMAND_LENGTH=`list_commands | tr ' ' '\n' | wc --max-line-length`
}

empty_list_commands_cache() {
	COMMANDS_NONE=
	COMMANDS_ID=
	COMMANDS_LIST=
	COMMANDS_NODE=
	MAX_COMMAND_LENGTH=
}

#########################################################################
#-- printing help --#
#####################

help_string() {
	#marker function that does absolutely nothing
	:
}

print_help_for_command() {
	#$1: command name
	#$2: suffix

	local FCTNAME="c_${1}_${2}"
	local DECLARE
	DECLARE=`declare -f -p $FCTNAME` || return 1
	echo "$DECLARE" | awk '
		BEGIN { pr=0 }
		/help_string/ && /";[[:space:]]*$/ {
			# a single line help. Just print it all.
			gsub(/^.*help_string[[:space:]]*"/,"")
			gsub(/";[[:space:]]*$/,"")
			print
			exit 0
		}

		/help_string/ {
			#beginning of the help: set flag to print other lines and remove unneccessary stuff.
			gsub(/^.*help_string[[:space:]]*"/,"")
			print
			pr=1
			next
		}
		
		/";[[:space:]]*$/ {
			#end of the help. Print last bit and exit
			gsub(/^[[:space:]]*/,"")
			gsub(/";[[:space:]]*$/,"")
			print
			pr=0
			exit 0
		}
		
		pr==1 {
			#line in between: Remove leading space
			gsub(/^[[:space:]]*/,"")
			print
			next
		}
	'
	return 0
}

print_help_for_category() {
	case "$1" in 
		list)
			EXTRA="<list>"
			;;
		id)
			EXTRA="<id>  "
			;;
		none)
			EXTRA="      "
			;;
		node)
			EXTRA="<id>  "
			;;
		*)
			echo "Cannot print help for unknown category $1"
			return 1
	esac

	#The amount of witespace we need for the lines (for multiline help) to be aligned:
	WHITE=$(printf "%$(( $(max_command_length) + 12 ))s" "")
	for cmd in `list_commands_$category`; do
		#width of the extra column (for alignment of first help line)
		local COLWIDTH=$(( $(max_command_length) + 6 - ${#cmd} ))
		printf "   \033[0;33m%s\033[0;00m %-${COLWIDTH}s  " "$cmd" "$EXTRA"

		print_help_for_command $cmd $category | sed "2,\$s/^/$WHITE/g"
	done
}

#########################################################################
#-- utils --#
#############

match_for_jobs() {
	# Tries to match the argument on $1 against the list of JobIDs 
	# and the list of jobnames of this user. 
	# Echos all matching jobids in the list form "jobid1 jobid2 jobid3"
	# If one or more IDs match returns 0, else 1

	[ -z "$1" ] && return 1
	qstat  -1 -n -u $USER | awk -v "pattern=$1" -v "user=$USER" '
		BEGIN {ret=1}
		$2 == user && ($1 ~ pattern || $4 ~ pattern) { printf "%s ", $1; ret=0 }
		END {print ""; exit ret}
	'
}

print_jobs() {
	#$@: a list of job ids
	qstat -u $USER $@
}

node_for_jobid() {
	# Expects a single jobid and echos the corresponding node.
	# returns 1 on any error, 0 on success.

	[ -z "$1" ] && return 1
	qstat  -1 -n "$1" | awk -v "user=$USER" -v "id=$1" '
		$2 == user {
			#get rid of /procnumber:
	       		gsub(/\/[0-9]+/,"",$12);

			#split at the +	
			split($12,a,"+")
			
			#check if all the same node
			node=a[1];
			for (ind in a) {
				if (a[ind] != node) {
					print("Found multiple nodes for jobid " id) > "/dev/stderr"
					exit 1
				}
			}
			print node
			exit 0
		}
	'
}

parse_job_args() {
	# parses all job args on $@ and echos a list of all matching job ids
	# If one or more IDs match returns 0, else 1

	local LIST=""
	while [ "$1" ]; do
		LIST="$LIST $(match_for_jobs $1)"
		shift
	done
	LIST=$(echo "$LIST" | sed 's/[[:space:]]+/ /g;s/^ //;s/ $//g')
	if [ -z "$LIST" ]; then
		return 1
	fi
	echo "$LIST"
	return 0
}

#########################################################################
#-- shell --#
#############

# GLOBAL variable containing the last execution time of tabcomplete
# where only a partial completion of the command was achieved
TAB_PARTIAL_LASTEXEC=0
tabcomplete() {
	# try to complete the READLINE_LINE
	
	# discard tab if no input on line
	[ -z "$READLINE_LINE" ] && return

	# remove leading whitespace:
	local NORMALISED="${READLINE_LINE##*( )}" #requires extglob again

	# if NORMALISED contains a space, we are already completing the args
	# => quit
	[[ $NORMALISED == *" "*  ]] && return
	#TODO completion for arguments

	# try to match command. If no match -> return
	local MATCHES
	MATCHES=$(list_commands_aliases | tr ' ' '\n' | grep "^$NORMALISED") || return

	# find longest substring in matches:
	local LONGCOMMON
	# In the awk script we go through all matches and determine
	# the longest common sequence of characters at the start of
	# all matches
	LONGCOMMON=`echo "$MATCHES" | awk '
		function commonstart(a,b) {
			# function to determine the longest sequence of characters
			# that starts both strings

			#determine minimum length of both strings
			len=length(a)
			if (length(b) < len) {
				len=length(b)
			}

			#determine longest common start:
			for(i = 1; i <= len; ++i) {
				if ( substr(a,i,1) != substr(b,i,1) ) {
					return substr(a,0,i-1)
				}
			}
			return substr(a,0,len)
		}
	
		BEGIN {comm="" };
		NR == 1 { comm=$0; next };
		NR > 1 { comm=commonstart(comm,$0); };
		END { print comm }
		'
	`
	
	if [[ $(echo -n "$MATCHES" | grep -c '^') == 1 ]]; then
		#single match: Tab complete
		READLINE_LINE="$MATCHES "
		READLINE_POINT=$(( ${#MATCHES} + 1))
		return
	fi

	# fill up to common chars:
	READLINE_LINE="$LONGCOMMON"
	READLINE_POINT=${#MATCHES}

	# pressed tab twice within 3 seconds
	if (( $(date +%s) - TAB_PARTIAL_LASTEXEC < 4  )); then
		#print list of matching commands
		echo -n "$MATCHES" | tr '\n' '   '
		echo
	fi
	TAB_PARTIAL_LASTEXEC=$(date +%s)
	return
}

shell_loop() {
	local RET=0

	#if only one job, than select it here, else empty
	LASTJOBID=`qstat -u $USER | awk -v "user=$USER" '
		BEGIN { ret=0 }
		$2 == user { 
			if (id != "") { ret=1; exit }; 
			id=$1
	      	}
		END { 
			if (ret==0) {
				print id; 
				exit 0
			}
			exit 1
		}
		'
	`

	echo "Welcome to the interactive PBS queue diagnosis tool."
	echo
	c_summary_none
	echo
	echo "Enter 'help' for a list of implemented commands or 'quit' to quit the shell"

	while true; do
		if [ $RET != 0 ]; then
			echo -e "rc: \033[0;32m$RET\033[0;00m"
		fi

		#tab completion with function tabcomplete:
		bind -x '"\t":"tabcomplete"';

		read -e -p "($(printf "%6s" "$LASTJOBID")) >" LINE
		
		if [ "$LINE" ]; then
			history -s "$LINE"
			run_command $LINE
			RET=$?
		fi
	done
}

substitute_alias() {
	#$1: command to expand
	#$2: nesting count
	#echos the expanded command on stdout, errors on stderr
	
	local NEST=${2:-0}
	local CMD=$1
	if ((NEST > 10)); then
		echo "substitute_alias reached nest count of 10" >&2
		echo "Executing command as is: $CMD" >&2
		echo "$CMD"
		return
	fi

	local ALIASES_INDICES=${!ALIASES[@]}
	case "$CMD" in
		#the @( ) and ?( ) patterns require extglob !!
		@(${ALIASES_INDICES// /|}))
			substitute_alias "${ALIASES[$CMD]}" "$((NEST+1))"
			return
			;;
		*)	echo "$CMD"
			return 
			;;
	esac
}

run_command() {
	# interpret and run a command
	# returns the return code of the function executed
	# reads and alters the global variable LASTJOBID via __rc_echo_joblist
	# $1: command
	# $2 to $n: arguments

	local CMD="$1"
	local LIST
	shift

	[ -z "$CMD" ] && return 0
	
	#fill command if neccessary:
	[ -z "$COMMANDS_NONE" ] && fill_list_commands_cache

	#substitute aliases:
	CMD=$(substitute_alias "$CMD")

	#categorise the command and interpret (in case it is a _none)
	local CMD_CATEGORY="none"
	case "$CMD" in
		#the @( ) and ?( ) patterns require extglob !!
		@(${COMMANDS_NONE// /|})?(+([[:space:]])*))
			c_${CMD}_none
			return $?
			;;
		@(${COMMANDS_ID// /|})?(+([[:space:]])*))
			CMD_CATEGORY="id"
			;;
		@(${COMMANDS_NODE// /|})?(+([[:space:]])*))
			CMD_CATEGORY="node"
			;;
		@(${COMMANDS_LIST// /|})?(+([[:space:]])*))
			CMD_CATEGORY="list"
			;;
		*)
			 echo "Unrecognised command: $CMD" >&2
			 echo "Type help for a list of commands" >&2
			 return 1
			 ;;
	esac
	
	#all categories need the list of job ids:
	if ! LIST=$(parse_job_args $@); then
		if [ "$LASTJOBID" ]; then
			LIST=$LASTJOBID
		else
			echo "No argument provided or no job matched" >&2
			return 1
		fi
	fi

	#if more than one match and category is not list, then tell user and exit
	if [ $(echo "$LIST" | wc -w) == 1 ]; then
		#in any case we will proceed => update LASTJOBID
		LASTJOBID="$LIST"
	elif [ "$CMD_CATEGORY" == "list" ]; then
		#here we proceed with multiple job ids
		LASTJOBID=""
	else
		#for all categories but list we need (but do not have) a unique ID
		echo "More than one job matched the pattern:" >&2
		print_jobs "$LIST" > /dev/stderr
		return 1
	fi

	#parse node and run
	local NODE
	if [ "$CMD_CATEGORY" == "node" ]; then
		if ! NODE=$(node_for_jobid "$LIST");then
			echo "Error finding node for jobid: $LIST" >&2
			return 1
		fi
		#run node command:
		c_${CMD}_node "$NODE" "$LIST"
		return $?
	fi

	#run all remaining commands:
	c_${CMD}_${CMD_CATEGORY} "$LIST"
	return $?
}

#########################################################################
#-- awk snippets --#
####################
AWK_TOSEC='
	function tosec(str) {
		#convert a string of the kind 00:00:00 to number of seconds

		if (str == "--") return 0
		n = split(str,ar,":")
		if (n==3) {
		       return 60*60*ar[1]+60*ar[2]+ar[3]
		}
		print "Cannot interpret time: " str > "/dev/stderr"
		return 0
	}
'


#########################################################################
#-- commands --#
################
#Note: - functions for commands start with a "c_", followed by the
#        commands name and a suffix for the kind of arguments the 
#        command requires:
#            - "_none" for no argument 
#            - "_id"   for a single job id
#            - "_list" for a list of job ids.
#            - "_node" for the node as the first arg 
#                      and the job id as the second argument
#      - they should contain a line with a help string starting with
#        "help_string" that documents the commands action shortly

c_quit_none() {
	help_string "Quit shell."
	exit 0
}

c_help_none() {
	help_string "print this help"
	#TODO improve and expand

	echo "The following commands are implemented:"
	for category in none id node list; do
		print_help_for_category $category
	done

	cat <<- EOF

	<id> is a job id or jobname (or a pattern for it)
	<list> is a list of job ids or same as <id>
	if pattern is not unique, the command only works for <list>

	
	Bugs / Suggestions / Feature Requests:
	      $DEVELOPER
	EOF
}

c_alias_none() {
	help_string "List defined aliases"
	local ALIASES_INDICES=${!ALIASES[@]}
	for ind in $ALIASES_INDICES; do 
		echo "alias $ind=\"${ALIASES[$ind]}\""
	done	
}

c_joblist_none() {
	help_string "print all jobs owned by $USER"
	qstat -nu $USER
	#TODO if queuing list estimated time of start using showstart
}

c_summary_none() {
	help_string "print a short summary including 
	- jobs running out of walltime 
	- recently submitted jobs 
	- summary of load on the cluster 
	- your fairshare stats"
	#TODO ideas: No of active nodes/processors, how many occupied by me
	# which node is the one that has free processors

	# cache:
	QUSER="$(qstat -u $USER)"
	if [[ $(echo -n "$QUSER" | grep -c "$USER") -lt $SUMMARY_MAXJOBS ]]; then
		echo "All jobs running:"
		echo "$QUSER"
	else
		echo "$SUMMARY_MAXJOBS most recently submitted jobs (run \"joblist\" for all):"
		echo "$QUSER" | awk 'BEGIN {pr=1}; pr==1 ; /^--------/ {pr==0; exit}'
		echo "$QUSER" | grep "$USER" | sort -r | head -n $SUMMARY_MAXJOBS
		#TODO if queuing list estimated time of start using showstart
	fi
	qstat -u $USER | awk -v "user=$USER" -v "abs=$WALLTIME_WARNING_ABS" -v "rel=$WALLTIME_WARNING_REL" "
		$AWK_TOSEC

		BEGIN {
			printed=0
		}

		function printonce() {
			if (printed==1) return
			print \"\"
			printf \"Jobs running \\033[0;31mout of walltime\\033[0;00m very soon:\n\"
			printed=1
		}

		\$2 == user && (tosec(\$9)-tosec(\$11)) < abs*60*60 { printonce(); print; next}
		\$2 == user && (tosec(\$9)-tosec(\$11)) < (rel*tosec(\$11)/100) { printonce(); print; next}
	"

	echo
	qnodes | awk '
       		BEGIN {curnode="";}
	       	
		curnode != "" && /^[[:space:]]*$/ {curnode="";next}
		/^[[:graph:]]+$/ { curnode=$0; next }
		
		curnode != "" && $1 == "state" && $3 == "offline" { curnode=""; next }
	       	curnode != "" && $1 == "np" { nodetotcpus[curnode]=$3; nodes[++nodecount]=curnode }
		curnode != "" && $1 == "properties" { nodeprops[curnode]= $3}
		curnode != "" && $1 == "jobs" { nodeavailcpus[curnode]= (nodetotcpus[curnode]-split($3,a,",")) }
		curnode != "" && $1 == "status" {
			avail=0  #available memory in kb
			tot=0	#total memory in kb
			
			#shift first two fields away:
			for (i=1; i <= NF; ++i) {
				$i=$(i+2)
			}
			
			split($0,a,",")
			for (ind in a) { 
				if (pos=match(a[ind],/^availmem=/)) {
					avail=substr(a[ind],pos+9)
					sub(/kb$/,"",avail)
				}
				if (pos=match(a[ind],/^totmem=/)) {
					tot=substr(a[ind],pos+7)
					sub(/kb$/,"",tot)
				}
			}
			nodeavailmem[curnode]=avail
			nodetotmem[curnode]=tot
		}
		
		END {
			maxlen=0 #max number of chars for the hostname
			for (i=1; i<=nodecount; ++i) {
				if (length(nodes[i]) > maxlen) {
					maxlen=length(nodes[i])
				}	
			}

			printf "%-" maxlen "s  %8s   %18s   %s\n", "Node", "availCPU", "%TOT (avail mem) MB", "properties"
			printf "%-" maxlen "s  %8s   %18s   %s\n", "----", "--------", "-------------------", "----------"
			for (i=1; i<=nodecount; ++i) {
				colbef=""
				colaft=""
				if (nodeavailcpus[nodes[i]] > 0) {
					colbef="\033[0;32m"
					colaft="\033[0;00m"	
				}
				printf "%-" maxlen "s  " colbef "%8s" colaft "  %6.2f%% %10iMB   %s\n", \
					nodes[i], nodeavailcpus[nodes[i]] "/" nodetotcpus[nodes[i]], \
					(nodeavailmem[nodes[i]]/nodetotmem[nodes[i]]), nodeavailmem[nodes[i]]/1024, nodeprops[nodes[i]]
			}
		}
		'

	echo
	echo "Fairshare place:"
	diagnose -f | awk -v "user=$USER" '
		BEGIN { pr=0 }
		pr > 0 && /^$/ { exit }
	       	pr==1 && /^-------------$/ { pr=2; next };
	       	pr == 0 && /^USER$/ { pr=1; next }
		pr == 2 { arr[$1]=$2; }
		pr == 2 && $0 ~ "^" user "\\*? " { userline=$0 ; user=$1; next }
		END { 
			n = asort(arr,sorted)
			i=1
			for(;i <=n;++i) { if(sorted[i] == arr[user]) break; }
			gsub("^" user,user " (" n-i+1 "th)",userline)

			#TODO make this better:
			print "FSInterval                %     Target       0       1       2"
			#print "FSWeight               ------- -------  1.0000  0.5000  0.2500"

			print userline 
		}
	'
}

#c_stats_id() {
#	help_string "display some job statistics"
#
#	echo $FUNCNAME called with args $@
#	#TODO
#}

#c_wtincrease_id() {
#	help_string "increase walltime by sending sysadmin an email"
#	echo $FUNCNAME called with args $@
#	#TODO
#}

c_login_node() {
	help_string "login to the job's node and set the working directory
	to be the job's TMPDIR (ie the location under /lscratch
	Make sure to configure the .ssh/config that a simple ssh node is enough."
	local NODE="$1"
	local ID="$2"
	ssh -t "$NODE" "cd /lscratch/$ID; bash -il"
}

c_top_node() {
	help_string "login to the job's node and call top"
	local NODE="$1"
	local ID="$2"
	ssh -t $NODE "top"
}

#c_delete_list() {
#	help_string "delete the jobs"
#	#deleteJob
#	echo $FUNCNAME called with args $@
#
#	#read -p "Sure you want to delete job $ID?  " RES
#	#if [ "$RES" == "y" ]; then
#	#	qdel $ID
#	#fi
#	#TODO
#}

#c_load_list() {
#	help_string "check load and memory usage"
#	#check the load and memory usage for this list of jobs
#	# (to see if one might be swapping)
#	echo $FUNCNAME called with args $@
#}

#########################################################################
#-- Start of script --#
#######################

MASTERHOSTNAME="ccserv1"
ADDSSHKEY=y
WALLTIME_WARNING_ABS=5  #hours
WALLTIME_WARNING_REL=10 #%
SUMMARY_MAXJOBS=10 #list max 10 jobs in summary

# should contain all variables that the main block
# of the config file can overwrite
# read by parse_config
ALLGLOBALSETTINGS="MASTERHOSTNAME ADDSSHKEY WALLTIME_WARNING_ABS WALLTIME_WARNING_REL SUMMARY_MAXJOBS"
declare -r ALLGLOBALSETTINGS

# associative bash array for the aliases
# indexed value is the aliased shortcut and 
# the value is the long form the alias expands to
declare -A ALIASES

# shortcut if user just wants help:
if [[ "$1" == "help" ]]; then
	run_command  "help"
	exit $?
elif [[ "$1" == "-h" || "$1" == "--help" ]];then
	script_usage
	exit 0
fi

# parse the config and do preliminary checks
parse_config
preliminary_checks

while [ "$1" ]; do
	case "$1" in
		-h|--help)
			script_usage 
			exit 0
			;;
		--add-sshkey)
			ADDSSHKEY=y
			;;
		--no-add-sshkey)
			ADDSSHKEY=n
			;;
		--)
			shift
			break
			;;
		-*)
			echo "Unrecognised commandline argument: $1" >&2
			echo "Run $(basename $0) -h for help." >&2
			exit 1
			;;
		*)
			break
			;;
	esac
	shift
done

#setup ssh keys
[ "$ADDSSHKEY" == "y" ] && setup_ssh_keys

if [ "$1" ]; then
	# There is stuff left on the commandline
	# => presumably the user does not want to run a shell
	#    but execute the command directly
	run_command $@
	exit $?
fi

shell_loop
