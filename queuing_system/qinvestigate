#!/bin/bash

if [ `hostname` != "ccserv1" ]; then
	echo "Sorry wrong host, please use ccserv1 to run this"
	exit 1
fi

if [ "$1" = "-h" ]; then
	cat << EOF
Toolkit to investigate and modify queue jobs efficiently.
For a list of implemented commands start the Skript and type "help".

Skript makes use of the variable \$USER to execute fiters on the queue, 
so changing this variable in the shell makes it work under a different
username. Logins still work under the name of current user, however.
EOF
	exit 0
fi

#Is there even a job in the queue
if qstat -u $USER | grep $USER > /dev/null; then
	#all fine
	:
else
	echo "!!!   You currently have no job in the queue; Terminating   !!!"
	exit 0
fi

#required for @( ) and ?( ) patterns in case ... and other pathname expansions
shopt -qs extglob

#TODO check for ssh agent and add key if not present
#TODO module to parse user-defined aliases from config file

#########################################################################
#-- command cache --#
#####################
list_commands() {
	#list all commands
	list_commands_none
	echo -n " "
	list_commands_id
	echo -n " "
	list_commands_list
	echo -n " "
	list_commands_node
}

list_commands_none() {
	#get list of commands that require no argument
	fill_list_commands_cache
	echo -n "$COMMANDS_NONE"
}

list_commands_id() {
	#get list of commands that require a single job id
	fill_list_commands_cache
	echo -n "$COMMANDS_ID"
}

list_commands_list() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_LIST"
}

list_commands_node() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_NODE"
}

max_command_length(){
	#get maximum number of characters a command has
	fill_list_commands_cache
	echo -n "$MAX_COMMAND_LENGTH"
}

fill_list_commands_cache() {
	#fill cache for the lists of available commands
	[ "$COMMANDS_NONE" ] && return
	COMMANDS_NONE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_none ().*/\1/p' | tr '\n' ' ')
	COMMANDS_ID=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_id ().*/\1/p' | tr '\n' ' ')
	COMMANDS_LIST=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_list ().*/\1/p' | tr '\n' ' ')
	COMMANDS_NODE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_node ().*/\1/p' | tr '\n' ' ')

	MAX_COMMAND_LENGTH=`list_commands | tr ' ' '\n' | wc --max-line-length`
}

empty_list_commands_cache() {
	COMMANDS_NONE=
	COMMANDS_ID=
	COMMANDS_LIST=
	COMMANDS_NODE=
	MAX_COMMAND_LENGTH=
}

#########################################################################
#-- printing help --#
#####################

help_string() {
	#marker function that does absolutely nothing
	:
}

print_help_for_command() {
	#$1: command name
	#$2: suffix

	local FCTNAME="c_${1}_${2}"
	local DECLARE
	DECLARE=`declare -f -p $FCTNAME` || return 1
	echo "$DECLARE" | awk '
		BEGIN { pr=0 }
		/help_string/ && /";[[:space:]]*$/ {
			# a single line help. Just print it all.
			gsub(/^.*help_string[[:space:]]*"/,"")
			gsub(/";[[:space:]]*$/,"")
			print
			exit 0
		}

		/help_string/ {
			#beginning of the help: set flag to print other lines and remove unneccessary stuff.
			gsub(/^.*help_string[[:space:]]*"/,"")
			print
			pr=1
			next
		}
		
		/";[[:space:]]*$/ {
			#end of the help. Print last bit and exit
			gsub(/^[[:space:]]*/,"")
			gsub(/";[[:space:]]*$/,"")
			print
			pr=0
			exit 0
		}
		
		pr==1 {
			#line in between: Remove leading space
			gsub(/^[[:space:]]*/,"")
			print
			next
		}
	'
	return 0
}

print_help_for_category() {
	case "$1" in 
		list)
			EXTRA="<list>"
			;;
		id)
			EXTRA="<id>  "
			;;
		none)
			EXTRA="      "
			;;
		node)
			EXTRA="<id>  "
			;;
		*)
			echo "Cannot print help for unknown category $1"
			return 1
	esac

	#The amount of witespace we need for the lines (for multiline help) to be aligned:
	WHITE=$(printf "%$(( $(max_command_length) + 12 ))s" "")
	for cmd in `list_commands_$category`; do
		#width of the extra column (for alignment of first help line)
		local COLWIDTH=$(( $(max_command_length) + 6 - ${#cmd} ))
		printf "   \033[0;33m%s\033[0;00m %-${COLWIDTH}s  " "$cmd" "$EXTRA"

		print_help_for_command $cmd $category | sed "2,\$s/^/$WHITE/g"
	done
}

#########################################################################
#-- utils --#
#############

match_for_jobs() {
	# Tries to match the argument on $1 against the list of JobIDs 
	# and the list of jobnames of this user. 
	# Echos all matching jobids in the list form "jobid1 jobid2 jobid3"
	# If one or more IDs match returns 0, else 1

	[ -z "$1" ] && return 1
	qstat  -1 -n -u $USER | awk -v "pattern=$1" -v "user=$USER" '
		BEGIN {ret=1}
		$2 == user && ($1 ~ pattern || $4 ~ pattern) { printf "%s ", $1; ret=0 }
		END {print ""; exit ret}
	'
}

print_jobs() {
	#$@: a list of job ids
	qstat -u $USER $@
}

node_for_jobid() {
	# Expects a single jobid and echos the corresponding node.
	# returns 1 on any error, 0 on success.

	[ -z "$1" ] && return 1
	qstat  -1 -n "$1" | awk -v "user=$USER" -v "id=$1" '
		$2 == user {
			#get rid of /procnumber:
	       		gsub(/\/[0-9]+/,"",$12);

			#split at the +	
			split($12,a,"+")
			
			#check if all the same node
			node=a[1];
			for (ind in a) {
				if (a[ind] != node) {
					print("Found multiple nodes for jobid " id) > "/dev/stderr"
					exit 1
				}
			}
			print node
			exit 0
		}
	'
}

parse_job_args() {
	# parses all job args on $@ and echos a list of all matching job ids
	# If one or more IDs match returns 0, else 1

	local LIST=""
	while [ "$1" ]; do
		LIST="$LIST $(match_for_jobs $1)"
		shift
	done
	LIST=$(echo "$LIST" | sed 's/[[:space:]]+/ /g;s/^ //;s/ $//g')
	if [ -z "$LIST" ]; then
		return 1
	fi
	echo "$LIST"
	return 0
}

#########################################################################
#-- shell --#
#############

shell_loop() {
	LASTJOBID=""
	local RET=0

	echo "Welcome to the interactive PBS queue diagnosis tool."
	echo
	c_summary_none
	echo
	echo "Enter 'help' for a list of implemented commands or 'quit' to quit the shell"

	while true; do
		if [ $RET != 0 ]; then
			echo -e "rc: \033[0;32m$RET\033[0;00m"
		fi

		read -e -p "($(printf "%6s" "$LASTJOBID")) >" LINE
		
		if [ "$LINE" ]; then
			history -s "$LINE"
			run_command $LINE
			RET=$?
		fi
	done
}

substitute_alias() {
	#$1: command to expand
	#$2: nesting count
	#echos the expanded command on stdout, errors on stderr
	
	local NEST=${2:-0}
	local CMD=$1
	if ((NEST > 10)); then
		echo "substitute_alias reached nest count of 10" >&2
		echo "Executing command as is: $CMD" >&2
		echo "$CMD"
	fi

	#TODO: modularise

	case "$CMD" in
		q)	substitute_alias "quit" "$((NEST+1))"
			return
			;;
		*)	echo "$CMD"
			return 
			;;
	esac
}

run_command() {
	# interpret and run a command
	# returns the return code of the function executed
	# reads and alters the global variable LASTJOBID via __rc_echo_joblist
	# $1: command
	# $2 to $n: arguments

	local CMD="$1"
	local LIST
	shift

	[ -z "$CMD" ] && return 0
	
	#fill command if neccessary:
	[ -z "$COMMANDS_NONE" ] && fill_list_commands_cache

	#substitute aliases:
	CMD=$(substitute_alias "$CMD")

	#categorise the command and interpret (in case it is a _none)
	local CMD_CATEGORY="none"
	case "$CMD" in
		#the @( ) and ?( ) patterns require extglob !!
		@(${COMMANDS_NONE// /|})?(+([[:space:]])*))
			c_${CMD}_none
			return $?
			;;
		@(${COMMANDS_ID// /|})?(+([[:space:]])*))
			CMD_CATEGORY="id"
			;;
		@(${COMMANDS_NODE// /|})?(+([[:space:]])*))
			CMD_CATEGORY="node"
			;;
		@(${COMMANDS_LIST// /|})?(+([[:space:]])*))
			CMD_CATEGORY="list"
			;;
		*)
			 echo "Unrecognised command: $CMD" >&2
			 echo "Type help for a list of commands" >&2
			 return 1
			 ;;
	esac
	
	#all categories need the list of job ids:
	if ! LIST=$(parse_job_args $@); then
		if [ "$LASTJOBID" ]; then
			LIST=$LASTJOBID
		else
			echo "No argument provided or no job matched" >&2
			return 1
		fi
	fi

	#if more than one match and category is not list, then tell user and exit
	if [ $(echo "$LIST" | wc -w) == 1 ]; then
		#in any case we will proceed => update LASTJOBID
		LASTJOBID="$LIST"
	elif [ "$CMD_CATEGORY" == "list" ]; then
		#here we proceed with multiple job ids
		LASTJOBID=""
	else
		#for all categories but list we need (but do not have) a unique ID
		echo "More than one job matched the pattern:" >&2
		print_jobs "$LIST" > /dev/stderr
		return 1
	fi

	#parse node and run
	local NODE
	if [ "$CMD_CATEGORY" == "node" ]; then
		if ! NODE=$(node_for_jobid "$LIST");then
			echo "Error finding node for jobid: $LIST" >&2
			return 1
		fi
		#run node command:
		c_${CMD}_node "$NODE" "$LIST"
		return $?
	fi

	#run all remaining commands:
	c_${CMD}_${CMD_CATEGORY} "$LIST"
	return $?
}


#########################################################################
#-- commands --#
################
#Note: - functions for commands start with a "c_", followed by the
#        commands name and a suffix for the kind of arguments the 
#        command requires:
#            - "_none" for no argument 
#            - "_id"   for a single job id
#            - "_list" for a list of job ids.
#            - "_node" for the node as the first arg 
#                      and the job id as the second argument
#      - they should contain a line with a help string starting with
#        "help_string" that documents the commands action shortly
#      - if the command requires a single job id to work the functions
#        name has to 

c_quit_none() {
	help_string "Quit shell."
	exit 0
}

c_help_none() {
	help_string "print this help"
	#TODO

	echo "The following commands are implemented:"
	for category in none id node list; do
		print_help_for_category $category
	done

	cat <<- EOF

	<id> is a job id or jobname (or a pattern for it)
	<list> is a list of job ids or same as <id>
	if pattern is not unique, the command only works for <list>
	EOF
}

c_joblist_none() {
	help_string "print all jobs owned by $USER"
	qstat -nu $USER
}

c_summary_none() {
	help_string "print a short summary including 
	- jobs running out of walltime 
	- recently submitted jobs 
	- summary of load on the cluster 
	- your fairshare stats"
	#TODO ideas: fairShare, No of active nodes/processors, how many occupied by me
	#Jobs that are going to run out of walltime soon

	#Print 10 jobs of importance
	#
	#qstat -1 -n -u $USER | awk


	echo "5 joungest jobs"

	echo "5 jobs with smallest walltime"

	c_joblist_none


}

c_stats_id() {
	help_string "display some job statistics"
	#echo stats called
	echo $FUNCNAME called with args $@
}

c_wtincrease_id() {
	help_string "increase walltime by sending sysadmin an email"
	echo $FUNCNAME called with args $@
}

c_login_node() {
	help_string "login to the job's node and set the working directory
	to be the job's TMPDIR (ie the location under /lscratch"
	local NODE="$1"
	local ID="$2"
	ssh -t "$NODE" "cd /lscratch/$ID; bash -il"
}

c_top_node() {
	help_string "login to the job's node and call top"
	local NODE="$1"
	local ID="$2"
	ssh -t $NODE "top"
}

c_delete_list() {
	help_string "delete the jobs"
	#deleteJob
	echo $FUNCNAME called with args $@
}

c_load_list() {
	help_string "check load and memory usage"
	#check the load and memory usage for this list of jobs
	# (to see if one might be swapping)
	echo $FUNCNAME called with args $@
}

#------------------------------------------------------------------------

function displayHelp() {
	cat << EOF
The following commands are implemented at the moment:
help              displays this help
refresh           refresh qinvestigate display
login <ID>        login to node
top               login to node and execute "top"
quit              quit script
experimental      access experimental features.
                  Read code for doc ;)

shorter aliases:
h       same as   help
r                 refresh
q                 quit
l                 login

NOTE: Major refactoring of this code is going on at the moment
      the available methods are likely going to change very soon.
EOF
}

#------------------------------------------------------------------------

function deleteJob() {
	read -p "Sure you want to delete job $ID?  " RES
	if [ "$RES" == "y" ]; then
		qdel $ID
	fi
}


#------------------------------------------------------------------------

PROMPT="Type in command followed by job ID  (h for help; q quits)  > "
SUPRESS_QSTAT_ON_NEXT_RUN=0
while true; do
	if [ "$SUPRESS_QSTAT_ON_NEXT_RUN" != "1" ]; then
		echo current jobs owned by you:
		qstat -nu $USER | awk '$1 != "--"'
		echo
	else
		SUPRESS_QSTAT_ON_NEXT_RUN=0
	fi

	#read input from user
	ID=""
	COMM=""
	LINE=""
	read -e -p "$PROMPT" LINE
	history -s $LINE
	PROMPT="comm ID  > " #shorten future promts

	if [ "$LINE" == "" ]; then
		#if [ "$QINVESTIGATE_DEFAULT_COMMAND" ]; then
		#	LINE=$QINVESTIGATE_DEFAULT_COMMAND
		#else
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			continue
		#fi
	fi

	COMM=`echo $LINE | awk '{print $1}'`
	ID=`echo $LINE | awk '{print $2}'`

	#do functions without an argument here:
	case $COMM in 
		r)
			continue
			;;
		refresh)
			continue
			;;
		experimental)
			shell_loop
			continue
			;;
		q)
			exit 0
			;;
		quit)
			exit 0
			;;
		exit)
			exit 0
			;;
		h)
			echo
			displayHelp
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
			;;
		help)
			echo
			displayHelp
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
			;;
	esac
	echo

	#For all of the rest we need two arguments; if no second argument present try to default to single node if present.
	if [ "$ID" == "" ]; then
		QSTATUSER=`qstat -u $USER | grep $USER`
		if [[ "$QSTATUSER" != "" && `echo $QSTATUSER | awk '{if (NR > 1) {exit}}; END {print NR}'` == 1 ]]; then
			ID=`echo "$QSTATUSER" | awk '{print $1}'`
		else
			echo "!!!  Second argument missing  !!!"
			echo "!!!  Type \"help\" for a list of commands  !!!"
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
		fi
	fi

	# check for valid node argument:
	NODE=`qnodes | grep -B5 "$ID"`
	if [ $? != "0" ]; then
		echo "!!!  Sorry, could not find this host  !!!"
		SUPRESS_QSTAT_ON_NEXT_RUN=1
		echo
		continue
	fi
	if [ `echo "$NODE" | awk '{if (NR > 7) {exit}}; END {print NR}'` -gt "7" ];then
		echo "!!!  Sorry, more than one host did match your criteria  !!!"
		SUPRESS_QSTAT_ON_NEXT_RUN=1
		echo
		continue
	fi
	NODE=`echo "$NODE" | head -n1`

	#normalise ID input
	GREPID=`qstat | grep $ID`
	if [ `echo $GREPID | awk '{if (NR > 1) {exit}}; END {print NR}'` -gt 1 ]; then
		echo "  WARNING: failed to normalised ID input $ID"
		echo "           possible that some features like \"del\" don't work properly"
		read -p "           Continue with execution?  " RES
		if [ "$RES" != "y" ]; then
			echo
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			continue
		fi
	else
		ID=`echo "$GREPID" | awk '{print $1}'`
	fi

	#do functions with argument here
	case $COMM in
		ssh)
			c_login_node "$NODE" $ID
			;;
		login)
			c_login_node "$NODE" $ID
			;;
		l)
			c_login_node "$NODE" $ID
			;;
		llscratch)
			c_login_node "$NODE" $ID
			;;
		lls)
			c_login_node "$NODE" $ID
			;;
		top)
			c_top_node "$NODE" $ID
			;;

	#-------------------------------------
		*)
			echo "!!!  Unrecognised command: $COMM  !!!"
			echo "!!!  Type \"help\" for a list of commands  !!!"
			SUPRESS_QSTAT_ON_NEXT_RUN=1
			echo
			continue
	esac
done
