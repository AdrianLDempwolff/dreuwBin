#!/bin/bash

#TODO: move this block down to preliminary checks or so
if [ `hostname` != "ccserv1" ]; then
	echo "Sorry wrong host, please use ccserv1 to run this"
	exit 1
fi

if [ "$1" = "-h" ]; then
	cat << EOF
Toolkit to investigate and modify queue jobs efficiently.
For a list of implemented commands start the Skript and type "help".

Skript makes use of the variable \$USER to execute fiters on the queue, 
so changing this variable in the shell makes it work under a different
username. Logins still work under the name of current user, however.

Basic tab completion is available.
EOF
	exit 0
fi

#Is there even a job in the queue
if qstat -u $USER | grep $USER > /dev/null; then
	#all fine
	:
else
	echo "!!!   You currently have no job in the queue; Terminating   !!!"
	exit 0
fi

#required for @( ) and ?( ) patterns in case ... and other pathname expansions
shopt -qs extglob

# switch to vi line editing mode for the binding of \t to tabcomplete to work
# TODO offer options for vi vs emacs
set -o vi
set +o emacs

#TODO check for ssh agent and add key if not present
#TODO module to parse user-defined aliases from config file

#########################################################################
#-- command cache --#
#####################
list_commands() {
	#list all commands
	list_commands_none
	echo -n " "
	list_commands_id
	echo -n " "
	list_commands_list
	echo -n " "
	list_commands_node
}

list_commands_none() {
	#get list of commands that require no argument
	fill_list_commands_cache
	echo -n "$COMMANDS_NONE"
}

list_commands_id() {
	#get list of commands that require a single job id
	fill_list_commands_cache
	echo -n "$COMMANDS_ID"
}

list_commands_list() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_LIST"
}

list_commands_node() {
	#get list of commands that require a list of job ids
	fill_list_commands_cache
	echo -n "$COMMANDS_NODE"
}

max_command_length(){
	#get maximum number of characters a command has
	fill_list_commands_cache
	echo -n "$MAX_COMMAND_LENGTH"
}

fill_list_commands_cache() {
	#fill cache for the lists of available commands
	[ "$COMMANDS_NONE" ] && return
	COMMANDS_NONE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_none ().*/\1/p' | tr '\n' ' ')
	COMMANDS_ID=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_id ().*/\1/p' | tr '\n' ' ')
	COMMANDS_LIST=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_list ().*/\1/p' | tr '\n' ' ')
	COMMANDS_NODE=$(declare -f | sed -ne '/^c_.* ()/s/^c_\([[:graph:]]*\)_node ().*/\1/p' | tr '\n' ' ')

	MAX_COMMAND_LENGTH=`list_commands | tr ' ' '\n' | wc --max-line-length`
}

empty_list_commands_cache() {
	COMMANDS_NONE=
	COMMANDS_ID=
	COMMANDS_LIST=
	COMMANDS_NODE=
	MAX_COMMAND_LENGTH=
}

#########################################################################
#-- printing help --#
#####################

help_string() {
	#marker function that does absolutely nothing
	:
}

print_help_for_command() {
	#$1: command name
	#$2: suffix

	local FCTNAME="c_${1}_${2}"
	local DECLARE
	DECLARE=`declare -f -p $FCTNAME` || return 1
	echo "$DECLARE" | awk '
		BEGIN { pr=0 }
		/help_string/ && /";[[:space:]]*$/ {
			# a single line help. Just print it all.
			gsub(/^.*help_string[[:space:]]*"/,"")
			gsub(/";[[:space:]]*$/,"")
			print
			exit 0
		}

		/help_string/ {
			#beginning of the help: set flag to print other lines and remove unneccessary stuff.
			gsub(/^.*help_string[[:space:]]*"/,"")
			print
			pr=1
			next
		}
		
		/";[[:space:]]*$/ {
			#end of the help. Print last bit and exit
			gsub(/^[[:space:]]*/,"")
			gsub(/";[[:space:]]*$/,"")
			print
			pr=0
			exit 0
		}
		
		pr==1 {
			#line in between: Remove leading space
			gsub(/^[[:space:]]*/,"")
			print
			next
		}
	'
	return 0
}

print_help_for_category() {
	case "$1" in 
		list)
			EXTRA="<list>"
			;;
		id)
			EXTRA="<id>  "
			;;
		none)
			EXTRA="      "
			;;
		node)
			EXTRA="<id>  "
			;;
		*)
			echo "Cannot print help for unknown category $1"
			return 1
	esac

	#The amount of witespace we need for the lines (for multiline help) to be aligned:
	WHITE=$(printf "%$(( $(max_command_length) + 12 ))s" "")
	for cmd in `list_commands_$category`; do
		#width of the extra column (for alignment of first help line)
		local COLWIDTH=$(( $(max_command_length) + 6 - ${#cmd} ))
		printf "   \033[0;33m%s\033[0;00m %-${COLWIDTH}s  " "$cmd" "$EXTRA"

		print_help_for_command $cmd $category | sed "2,\$s/^/$WHITE/g"
	done
}

#########################################################################
#-- utils --#
#############

match_for_jobs() {
	# Tries to match the argument on $1 against the list of JobIDs 
	# and the list of jobnames of this user. 
	# Echos all matching jobids in the list form "jobid1 jobid2 jobid3"
	# If one or more IDs match returns 0, else 1

	[ -z "$1" ] && return 1
	qstat  -1 -n -u $USER | awk -v "pattern=$1" -v "user=$USER" '
		BEGIN {ret=1}
		$2 == user && ($1 ~ pattern || $4 ~ pattern) { printf "%s ", $1; ret=0 }
		END {print ""; exit ret}
	'
}

print_jobs() {
	#$@: a list of job ids
	qstat -u $USER $@
}

node_for_jobid() {
	# Expects a single jobid and echos the corresponding node.
	# returns 1 on any error, 0 on success.

	[ -z "$1" ] && return 1
	qstat  -1 -n "$1" | awk -v "user=$USER" -v "id=$1" '
		$2 == user {
			#get rid of /procnumber:
	       		gsub(/\/[0-9]+/,"",$12);

			#split at the +	
			split($12,a,"+")
			
			#check if all the same node
			node=a[1];
			for (ind in a) {
				if (a[ind] != node) {
					print("Found multiple nodes for jobid " id) > "/dev/stderr"
					exit 1
				}
			}
			print node
			exit 0
		}
	'
}

parse_job_args() {
	# parses all job args on $@ and echos a list of all matching job ids
	# If one or more IDs match returns 0, else 1

	local LIST=""
	while [ "$1" ]; do
		LIST="$LIST $(match_for_jobs $1)"
		shift
	done
	LIST=$(echo "$LIST" | sed 's/[[:space:]]+/ /g;s/^ //;s/ $//g')
	if [ -z "$LIST" ]; then
		return 1
	fi
	echo "$LIST"
	return 0
}

#########################################################################
#-- shell --#
#############

# GLOBAL variable containing the last execution time of tabcomplete
# where only a partial completion of the command was achieved
TAB_PARTIAL_LASTEXEC=0
tabcomplete() {
	# try to complete the READLINE_LINE
	
	# discard tab if no input on line
	[ -z "$READLINE_LINE" ] && return

	# remove leading whitespace:
	local NORMALISED="${READLINE_LINE##*( )}" #requires extglob again

	# if NORMALISED contains a space, we are already completing the args
	# => quit
	[[ $NORMALISED == *" "*  ]] && return
	#TODO completion for arguments

	# try to match command. If no match -> return
	local MATCHES
	MATCHES=$(list_commands | tr ' ' '\n' | grep "^$NORMALISED") || return

	# find longest substring in matches:
	local LONGCOMMON
	# In the awk script we go through all matches and determine
	# the longest common sequence of characters at the start of
	# all matches
	LONGCOMMON=`echo "$MATCHES" | awk '
		function commonstart(a,b) {
			# function to determine the longest sequence of characters
			# that starts both strings

			#determine minimum length of both strings
			len=length(a)
			if (length(b) < len) {
				len=length(b)
			}

			#determine longest common start:
			for(i = 1; i <= len; ++i) {
				if ( substr(a,i,1) != substr(b,i,1) ) {
					return substr(a,0,i-1)
				}
			}
			return substr(a,0,len)
		}
	
		BEGIN {comm="" };
		NR == 1 { comm=$0; next };
		NR > 1 { comm=commonstart(comm,$0); };
		END { print comm }
		'
	`
	
	if [[ $(echo -n "$MATCHES" | grep -c '^') == 1 ]]; then
		#single match: Tab complete
		READLINE_LINE="$MATCHES "
		READLINE_POINT=$(( ${#MATCHES} + 1))
		return
	fi

	# fill up to common chars:
	READLINE_LINE="$LONGCOMMON"
	READLINE_POINT=${#MATCHES}

	# pressed tab twice within 3 seconds
	if (( $(date +%s) - TAB_PARTIAL_LASTEXEC < 4  )); then
		#print list of matching commands
		echo -n "$MATCHES" | tr '\n' '   '
		echo
	fi
	TAB_PARTIAL_LASTEXEC=$(date +%s)
	return
}

shell_loop() {
	local RET=0

	#if only one job, than select it here, else empty
	LASTJOBID=`qstat -u $USER | awk -v "user=$USER" '
		BEGIN { ret=0 }
		$2 == user { 
			if (id != "") { ret=1; exit }; 
			id=$1
	      	}
		END { 
			if (ret==0) {
				print id; 
				exit 0
			}
			exit 1
		}
		'
	`

	echo "Welcome to the interactive PBS queue diagnosis tool."
	echo
	c_summary_none
	echo
	echo "Enter 'help' for a list of implemented commands or 'quit' to quit the shell"

	while true; do
		if [ $RET != 0 ]; then
			echo -e "rc: \033[0;32m$RET\033[0;00m"
		fi

		#tab completion with function tabcomplete:
		bind -x '"\t":"tabcomplete"';

		read -e -p "($(printf "%6s" "$LASTJOBID")) >" LINE
		
		if [ "$LINE" ]; then
			history -s "$LINE"
			run_command $LINE
			RET=$?
		fi
	done
}

substitute_alias() {
	#$1: command to expand
	#$2: nesting count
	#echos the expanded command on stdout, errors on stderr
	
	local NEST=${2:-0}
	local CMD=$1
	if ((NEST > 10)); then
		echo "substitute_alias reached nest count of 10" >&2
		echo "Executing command as is: $CMD" >&2
		echo "$CMD"
	fi

	#TODO: modularise

	case "$CMD" in
		q)	substitute_alias "quit" "$((NEST+1))"
			return
			;;
		*)	echo "$CMD"
			return 
			;;
	esac
}

run_command() {
	# interpret and run a command
	# returns the return code of the function executed
	# reads and alters the global variable LASTJOBID via __rc_echo_joblist
	# $1: command
	# $2 to $n: arguments

	local CMD="$1"
	local LIST
	shift

	[ -z "$CMD" ] && return 0
	
	#fill command if neccessary:
	[ -z "$COMMANDS_NONE" ] && fill_list_commands_cache

	#substitute aliases:
	CMD=$(substitute_alias "$CMD")

	#categorise the command and interpret (in case it is a _none)
	local CMD_CATEGORY="none"
	case "$CMD" in
		#the @( ) and ?( ) patterns require extglob !!
		@(${COMMANDS_NONE// /|})?(+([[:space:]])*))
			c_${CMD}_none
			return $?
			;;
		@(${COMMANDS_ID// /|})?(+([[:space:]])*))
			CMD_CATEGORY="id"
			;;
		@(${COMMANDS_NODE// /|})?(+([[:space:]])*))
			CMD_CATEGORY="node"
			;;
		@(${COMMANDS_LIST// /|})?(+([[:space:]])*))
			CMD_CATEGORY="list"
			;;
		*)
			 echo "Unrecognised command: $CMD" >&2
			 echo "Type help for a list of commands" >&2
			 return 1
			 ;;
	esac
	
	#all categories need the list of job ids:
	if ! LIST=$(parse_job_args $@); then
		if [ "$LASTJOBID" ]; then
			LIST=$LASTJOBID
		else
			echo "No argument provided or no job matched" >&2
			return 1
		fi
	fi

	#if more than one match and category is not list, then tell user and exit
	if [ $(echo "$LIST" | wc -w) == 1 ]; then
		#in any case we will proceed => update LASTJOBID
		LASTJOBID="$LIST"
	elif [ "$CMD_CATEGORY" == "list" ]; then
		#here we proceed with multiple job ids
		LASTJOBID=""
	else
		#for all categories but list we need (but do not have) a unique ID
		echo "More than one job matched the pattern:" >&2
		print_jobs "$LIST" > /dev/stderr
		return 1
	fi

	#parse node and run
	local NODE
	if [ "$CMD_CATEGORY" == "node" ]; then
		if ! NODE=$(node_for_jobid "$LIST");then
			echo "Error finding node for jobid: $LIST" >&2
			return 1
		fi
		#run node command:
		c_${CMD}_node "$NODE" "$LIST"
		return $?
	fi

	#run all remaining commands:
	c_${CMD}_${CMD_CATEGORY} "$LIST"
	return $?
}


#########################################################################
#-- commands --#
################
#Note: - functions for commands start with a "c_", followed by the
#        commands name and a suffix for the kind of arguments the 
#        command requires:
#            - "_none" for no argument 
#            - "_id"   for a single job id
#            - "_list" for a list of job ids.
#            - "_node" for the node as the first arg 
#                      and the job id as the second argument
#      - they should contain a line with a help string starting with
#        "help_string" that documents the commands action shortly
#      - if the command requires a single job id to work the functions
#        name has to 

c_quit_none() {
	help_string "Quit shell."
	exit 0
}

c_help_none() {
	help_string "print this help"
	#TODO improve and expand

	echo "The following commands are implemented:"
	for category in none id node list; do
		print_help_for_category $category
	done

	cat <<- EOF

	<id> is a job id or jobname (or a pattern for it)
	<list> is a list of job ids or same as <id>
	if pattern is not unique, the command only works for <list>
	EOF
}

c_alias_none() {
	help_string "List defined aliases
	(NOT YET IMPLEMENTED)"
	#TODO implement

	echo $FUNCNAME called with args $@
}

c_joblist_none() {
	help_string "print all jobs owned by $USER"
	qstat -nu $USER
}

c_summary_none() {
	help_string "print a short summary including 
	- jobs running out of walltime 
	- recently submitted jobs 
	- summary of load on the cluster 
	- your fairshare stats
	(NOT FULLY IMPLEMENTED)"
	#TODO ideas: fairShare, No of active nodes/processors, how many occupied by me
	#Jobs that are going to run out of walltime soon

	#Print 10 jobs of importance
	#
	#qstat -1 -n -u $USER | awk


	echo "5 joungest jobs"

	echo "5 jobs with smallest walltime"

	c_joblist_none
}

c_stats_id() {
	help_string "display some job statistics
	(NOT YET IMPLEMENTED)"
	#echo stats called
	echo $FUNCNAME called with args $@
}

c_wtincrease_id() {
	help_string "increase walltime by sending sysadmin an email
	(NOT YET IMPLEMENTED)"
	echo $FUNCNAME called with args $@
}

c_login_node() {
	help_string "login to the job's node and set the working directory
	to be the job's TMPDIR (ie the location under /lscratch"
	local NODE="$1"
	local ID="$2"
	ssh -t "$NODE" "cd /lscratch/$ID; bash -il"
}

c_top_node() {
	help_string "login to the job's node and call top"
	local NODE="$1"
	local ID="$2"
	ssh -t $NODE "top"
}

c_delete_list() {
	help_string "delete the jobs
	(NOT YET IMPLEMENTED)"
	#deleteJob
	echo $FUNCNAME called with args $@

	#read -p "Sure you want to delete job $ID?  " RES
	#if [ "$RES" == "y" ]; then
	#	qdel $ID
	#fi
}

c_load_list() {
	help_string "check load and memory usage
	(NOT YET IMPLEMENTED)"
	#check the load and memory usage for this list of jobs
	# (to see if one might be swapping)
	echo $FUNCNAME called with args $@
}

#########################################################################
#-- Start of script --#
#######################
shell_loop
